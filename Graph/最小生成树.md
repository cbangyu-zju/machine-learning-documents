## 最小生成树模型

### Prim算法
#### 1. 概论
普里姆算法(Prim算法)，图论中的一种简单算法，可以在加权连通图中搜索最小生成树。即：由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和最小。

#### 2. 算法描述
1. 输入：一个加权连通图，其顶点集合为V，边集合为E；
2. 初始化： Vnew = {x}, 其中x为集合V中的任一节点(起始点)，Enew = {}，为空
3. 重复下列操作，直到Vnew = V:
	1. 在集合E中选取权值最小的边(u, v)，其中u为集合Vnew中的元素，而v不在Vnew集合中，并且v∈V
	2. 将v加入集合Vnew中，将(u, v)边加入集合Enew中
4. 输出：使用集合Vnew和Enew来描述所得到的最小生成树

#### 3. 证明Prim算法
反证法：假设Prim生成的树不是最小生成树

1. 设Prim生成的树为G0；
2. 假设存在Gmin使得 cost(Gmin) < cost(G0) 则在Gmin中存在 <u, v> 不属于G0
3. 将(u, v)加入G0可得到一个环，且<u, v>不是该环的最短边
4. 这与Prim每次生成最短边矛盾
5. 顾假设不成立，免提的证


外链介绍:
[wiki](https://en.wikipedia.org/wiki/Prim%27s_algorithm)
[中文介绍](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html)

### Kruskal 算法

#### 1. 概论
Kruskal算法是一种用来寻找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪婪算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。

#### 2. 算法描述
1. 记G中有v个顶点，e个边；
2. 新建图Gnew，Gnew中拥有和原图中相同的e个顶点，但没有边
3. 将原图G中的所有e个边按权值从小到大排序
4. 循环：从权值最小的边开始遍历每条边 直至图G中所有的节点都在同一个连通分量中
	1. if 这条边连接的两个节点于图Gnew中不在同一个连通分量中
	2. 添加这条边到图Gnew中

#### 3. 简单证明Kruskal算法

对图的顶点数n做归纳，证明Kruskal算法对任意n阶图适用。

1. n=1，显然能够找到最小生成树。
2. 假设Kruskal算法对n≤k阶图适用，那么，在k+1阶图G中，我们把最短边的两个端点a和b做一个合并操作，即把u与v合为一个点v'，把原来接在u和v的边都接到v'上去，这样就能够得到一个k阶图G'(u,v的合并是k+1少一条边)，G'最小生成树T'可以用Kruskal算法得到。
3. 我们证明 T'+{(u, v)} 是G的最小生成树。用反证法，如果T'+{(u, v)}不是最小生成树，最小生成树是T，即W(T)<W(T'+{(u, v)})。显然T应该包含<u,v>，否则，可以用(u, v)加入到T中，形成一个环，删除环上原有的任意一条边，形成一棵更小权值的生成树。而T-{(u, v)s}，是G'的生成树。所以W(T-{(u, v)})<=W(T')，也就是W(T)<=W(T')+W((u, v))=W(T'+{(u, v)})，产生了矛盾。于是假设不成立，T'+{(u, v)}是G的最小生成树，Kruskal算法对k+1阶图也适用。

由数学归纳法，Kruskal算法得证。

外链介绍:
[wiki](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm)
[中文介绍](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html)